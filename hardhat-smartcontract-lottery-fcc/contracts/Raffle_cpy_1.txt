// SPDX-License-Identifier: MIT
pragma solidity 0.8.30;

import "@chainlink/contracts/src/v0.8/vrf/dev/VRFConsumerBaseV2Plus.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/interfaces/IVRFCoordinatorV2Plus.sol";
import "@chainlink/contracts/src/v0.8/vrf/dev/libraries/VRFV2PlusClient.sol";
import { AutomationCompatibleInterface } from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";

import "hardhat/console.sol";

// Raffle meaning a lottery

error Raffle__NotEnoughETHEntered();
error Raffle__TransferFailed();
error Raffle__NotOpen();
error Raffle__UpKeepNotNeeded(
    uint256 currentState,
    uint256 numPlayers,
    uint256 contractBalance
);

/*
    @author Sathiya
    @title A sample Raffle Contract
    @notice This contract is for creating an untamperable decentralized smart contract lottery

*/

contract Raffle is VRFConsumerBaseV2Plus, AutomationCompatibleInterface {
    /* State Variables */
    enum RaffleState {
        OPEN,
        CALCULATING
    } // uint256 0 = OPEN, 1 = CALCULATING

    uint256 private immutable i_entranceFee;
    address payable[] private s_players; // A payable address explicitly means "this address can receive ETH".
    IVRFCoordinatorV2Plus private immutable i_vrfCoordinator;
    bytes32 private immutable i_gasLane;
    uint256 private immutable i_subscriptionId;
    uint16 private constant REQUEST_CONFIRMATIONS = 3;
    uint32 private constant CALLBACK_GAS_LIMIT = 2500000; // 2,500,000 gas
    uint32 private constant NUM_WORDS = 1;
    RaffleState private s_raffleState;
    uint256 private s_lastTimeStamp;
    uint256 private immutable i_interval;
    address private s_recentWinner;

    event RaffleEnter(address indexed player);
    event RequestedRaffleWinner(uint256 indexed requestId);
    event WinnerPicked(address indexed winner);

    constructor(
        address vrfCoordinatorV2Plus,
        uint256 entranceFee,
        bytes32 gasLane,
        uint256 subscriptionId,
        uint32 interval
    ) VRFConsumerBaseV2Plus(vrfCoordinatorV2Plus) {
        i_entranceFee = entranceFee;
        i_vrfCoordinator = IVRFCoordinatorV2Plus(vrfCoordinatorV2Plus);
        i_gasLane = gasLane;
        i_subscriptionId = subscriptionId;
        s_raffleState = RaffleState.OPEN;
        s_lastTimeStamp = block.timestamp;
        i_interval = interval;
    }

    /*
    In Solidity, when a function is declared payable and someone calls it with some msg.value, that ether automatically gets credited to the contract‚Äôs balance ‚Äî you don‚Äôt need to explicitly ‚Äútransfer it to the contract.‚Äù
    */
    function enterRaffle() public payable {
        // require msg.value to be at least entrance fee
        if (msg.value < i_entranceFee) {
            revert Raffle__NotEnoughETHEntered();
        }
        // console.log("Owner:", msg.sender);
        // console.log("Owner:", uint256(s_raffleState));
        if (s_raffleState != RaffleState.OPEN) {
            revert Raffle__NotOpen();
        }
        s_players.push(payable(msg.sender)); // payable because we want to pay them later
        emit RaffleEnter(msg.sender);
    }

    /*
        1. atleast 1 player
        2. contract should have some ETH
        3. (block.timestamp - lastTimeStamp) > interval
        4. upkeepNeeded should be true
        5. flag should be open

    */

    function checkUpkeep(
        bytes memory /* checkData */
    )
        public
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        bool isOpen = (s_raffleState == RaffleState.OPEN);
        bool timePassed = ((block.timestamp - s_lastTimeStamp) > i_interval);
        bool hasPlayers = (s_players.length > 0);
        bool hasBalance = address(this).balance > 0;
        upkeepNeeded = (isOpen && hasPlayers && hasBalance && timePassed);
    }

    // function RequestedRandomWinner() external {
    function performUpkeep(bytes calldata /* performData */) external override {
        (bool upkeepNeeded, ) = checkUpkeep("");
        if (!upkeepNeeded) {
            revert Raffle__UpKeepNotNeeded(
                uint256(s_raffleState),
                s_players.length,
                address(this).balance
            );
        }
        s_raffleState = RaffleState.CALCULATING;
        // console.log("Raffle State:", uint256(s_raffleState));
        // uint256 requestId = i_vrfCoordinator.requestRandomWords(
        //     i_gasLane,
        //     i_subscriptionId,
        //     REQUEST_CONFIRMATIONS,
        //     CALLBACK_GAS_LIMIT,
        //     NUM_WORDS
        // );

        VRFV2PlusClient.RandomWordsRequest memory request = VRFV2PlusClient
            .RandomWordsRequest({
                keyHash: i_gasLane,
                subId: i_subscriptionId, // ‚ö†Ô∏è change type to uint256 above
                requestConfirmations: REQUEST_CONFIRMATIONS,
                callbackGasLimit: CALLBACK_GAS_LIMIT,
                numWords: NUM_WORDS,
                extraArgs: VRFV2PlusClient._argsToBytes(
                    VRFV2PlusClient.ExtraArgsV1({ nativePayment: false })
                )
            });

        uint256 requestId = i_vrfCoordinator.requestRandomWords(request);

        // uint32 callbackGasLimit

        // After VRF generates randomness, the Coordinator calls your contract back on fulfillRandomWords().

        // This function consumes gas, and you have to predefine the maximum gas VRF is allowed to spend for this callback.

        // üëâ Why important?

        // If you set too low, your fulfillRandomWords may run out of gas ‚Üí callback fails ‚Üí you don‚Äôt get your random numbers.

        // If you set too high, you might overpay or hit block gas limits. = CALLBACK_GAS_LIMIT;

        // CALLBACK_GAS_LIMI based on this only is the gas limit for fulfillRandomWords function
        // after calling the requestRandomWords function, it will return a requestId
        // And then the Chainlink node will eventually call the fulfillRandomWords function
        // on successful request, we get a requestId and it would call the fulfillRandomWords function

        // this is redundant
        emit RequestedRaffleWinner(requestId);
    }

    function fulfillRandomWords(
        uint256 /* requestId */,
        uint256[] calldata randomWords
    ) internal override {
        // console.log(randomWords[0]);
        // Logic to pick a random winner
        uint256 indexOfWinner = randomWords[0] % s_players.length;
        address payable recentWinner = s_players[indexOfWinner];

        (bool success, ) = recentWinner.call{ value: address(this).balance }(
            ""
        );

        if (!success) {
            revert Raffle__TransferFailed();
        }
        s_raffleState = RaffleState.OPEN;
        s_players = new address payable[](0); // reset the players array
        s_recentWinner = recentWinner;
        s_lastTimeStamp = block.timestamp;
        emit WinnerPicked(recentWinner);
    }

    /* View / Pure functions */

    function getEntranceFee() public view returns (uint256) {
        return i_entranceFee;
    }

    function getPlayer(
        uint256 playerIndex
    ) public view returns (address payable) {
        return s_players[playerIndex];
    }

    function getRecentWinner() public view returns (address) {
        return s_recentWinner;
    }

    function getRaffleState() public view returns (RaffleState) {
        return s_raffleState;
    }

    function getInterval() public view returns (uint256) {
        return i_interval;
    }

    function getNumWords() public pure returns (uint256) {
        return NUM_WORDS;
    }

    function getNumberOfPlayer() public view returns (uint256) {
        return s_players.length;
    }

    function getLatestTimeStamp() public view returns (uint256) {
        return s_lastTimeStamp;
    }

    function getRequestConfirmations() public pure returns (uint256) {
        return REQUEST_CONFIRMATIONS;
    }
}
